package oj_solution.oj_172_factorial_trailing_zeroes;

public class Solution {
	/**
	 * 通过分析阶乘，首先可以获知，末尾的0都是由阶乘数字中的
	 * 10（20/30/...）和5乘一个偶数贡献的，由于阶乘中5后面必然跟一个偶数，
	 * 不必考虑偶数不足的问题。进一步考虑，10其实也是由5x偶数
	 * 得来。由此，问题转化为，计算阶乘数字n包含有多少个偶数的问题。
	 * 显然，n/5即得，但这只是对于非5阶乘数有效。
	 * 例如：25! 25包含有2个5，也就意味着25!需要25/5+1
	 * 100! 有4个25，就需要额外加4，即100/5+4
	 * 
	 * 25	额外加1个
	 * 125	额外加2个
	 * ...
	 *
	 * 但可以如下操作：
	 * 1、n除以5，获得5的因子个数n1
	 * 2、n/5 再除以5，此时实际获得的是25的因子个数n2，由于25在步骤1中已经
	 * 计算过一次，n1+n2即可得小于125的任意n的结果
	 * 3、n/25再除以5，此时实际获得的是125的因子个数n3
	 * ……
	 * 
	 * 不断迭代即可得到最终结果。
	 * 用递归实现比较方便，见下面实现。
	 * 
	 * discuss分析参见：
	 * https://discuss.leetcode.com/topic/6513/simple-c-c-solution-with-detailed-explaination
	 * 同时此帖还给出了本题的非递归实现（分别算出5 25 125 ...的个数，加到一起）
	 * @param n
	 * @return
	 */
	public int trailingZeroes(int n) {
        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
    }
}
